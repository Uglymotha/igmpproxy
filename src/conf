config.c:        if (CONFRELOAD) IfDp->oldconf = IfDp->conf;
config.c:        for (confPtr = vifConf; confPtr && strcmp(IfDp->Name, confPtr->name) != 0; confPtr = confPtr->next);
config.c:            LOG(LOG_DEBUG, 0, "Found config for %s", IfDp->Name);
config.c:                for (alias = IfDp->aliases; alias; alias = alias->next, filter = confPtr->filters) {
config.c:            LOG(LOG_DEBUG, 0, "configureVifs: Creating default config for %s interface %s.", IS_DISABLED(commonConfig.defaultInterfaceState) ? "disabled" : IS_UPDOWNSTREAM(commonConfig.defaultInterfaceState) ? "updownstream" : IS_UPSTREAM(commonConfig.defaultInterfaceState) ? "upstream" : "downstream", IfDp->Name);
config.c:            strcpy(confPtr->name, IfDp->Name);
config.c:        IfDp->conf      = confPtr;
config.c:        if (! IfDp->oldconf) {
config.c:            IfDp->oldconf = confPtr;
config.c:            if (!(IfDp->state & 0x80)) {
config.c:                IfDp->oldconf->state = IfDp->state;
config.c:                IfDp->state          = IF_STATE_DISABLED | 0x80;
config.c:                IfDp->state          = IfDp->mtu && IfDp->Flags & IFF_MULTICAST ? IfDp->conf->state & ~0x80 : IF_STATE_DISABLED;
config.c:                IfDp->oldconf->state = IF_STATE_DISABLED;
config.c:            IfDp->oldconf->state = IfDp->state | (IfDp->conf->state & 0x80);
config.c:            IfDp->state          = IfDp->mtu && IfDp->Flags & IFF_MULTICAST ? IfDp->conf->state & ~0x80 : IF_STATE_DISABLED;
config.c:            confPtr->qry.ip = IfDp->InAdr.s_addr;
config.c:        if (!IS_DOWNSTREAM(IfDp->state))
config.c:        if (!(IfDp->conf->state & 0x80) && !confPtr->compat && !confPtr->nodefaultfilter && !CONFIG->nodefaultFilter) {
config.c:            for (struct filters *filter = IfDp->aliases; filter; allocFilter(CONFIG->defaultFilterAny ? (struct filters){ {0, 0}, {0,0}, ALLOW, 3, NULL } : *filter), filter = filter->next);
config.c:            IfDp->conf->state |= 0x80;   // Flag configuration
config.c:        if (! IfDp->conf->qry.election && IS_DOWNSTREAM(newstate) && IS_DOWNSTREAM(oldstate) && IfDp->querier.ip != IfDp->conf->qry.ip)
config.c:        if (!IS_DISABLED(newstate) && (IfDp->index != (uint8_t)-1 || k_addVIF(IfDp))) {
config.c:        if (IS_DISABLED(newstate) && IfDp->index != (uint8_t)-1) {
config.c:        IfDp->oldconf = NULL;
ifvc.c:        nIfDp = IfDp->next;
ifvc.c:        if (!clean || (clean && IfDp->conf && (IfDp->state & 0x80))) {
ifvc.c:                LOG(LOG_DEBUG, 0, "freeIfDescL: Interface %s disappeared, removing from list.", IfDp->Name);
ifvc.c:            for (struct filters *fil = IfDp->aliases, *nfil = NULL; fil; nfil = fil->next, free(fil), fil = nfil);  // Alloced by buildIfVc()
ifvc.c:                pIfDp->next = IfDp->next;
ifvc.c:                IfDescL = IfDp->next;
ifvc.c:            IfDp->oldconf = NULL;
ifvc.c:        if ((IfDp = getIfByName(tmpIfAddrsP->ifa_name)) && (! IfDp->conf)) {
ifvc.c:            for (fil = IfDp->aliases; fil && ! ((addr & fil->src.mask) == fil->src.ip); fil = fil->next);
ifvc.c:                fil = IfDp->aliases;
ifvc.c:                if (! (IfDp->aliases = (struct filters *)malloc(sizeof(struct filters))))
ifvc.c:                *IfDp->aliases = (struct filters){ {subnet, mask}, {INADDR_ANY, 0}, ALLOW, (uint8_t)-1, fil };
ifvc.c:            LOG(LOG_INFO, 0, "builfIfVc: Interface %s Addr: %s, Network: %s, Ptr: %p", IfDp->Name ,inetFmt(addr, 1), inetFmts(subnet, mask, 2), IfDp->aliases);
ifvc.c:            memcpy(IfDp->Name, tmpIfAddrsP->ifa_name, IF_NAMESIZE);
ifvc.c:            IfDp->Name[IF_NAMESIZE - 1] = '\0';
ifvc.c:            for (fil = IfDp->aliases; fil; nfil = fil->next, free(fil), fil = nfil);   // Alloced by self
ifvc.c:            IfDp->oldconf = IfDp->conf;
ifvc.c:            IfDp->conf    = NULL;
ifvc.c:        IfDp->Flags        = tmpIfAddrsP->ifa_flags;
ifvc.c:        IfDp->InAdr.s_addr = addr;
ifvc.c:            LOG(LOG_WARNING, errno, "buildIfVc: Failed to get MTU for %s, disabling.", IfDp->Name);
ifvc.c:            IfDp->mtu = ifr.ifr_mtu;
ifvc.c:        if (! (IfDp->Flags & IFF_MULTICAST)) {
ifvc.c:            ifr.ifr_flags = IfDp->Flags | IFF_MULTICAST;
ifvc.c:                LOG(LOG_WARNING, errno, "buildIfVc: Failed to enable multicast on %s, disabling.", IfDp->Name);
ifvc.c:                IfDp->Flags = ifr.ifr_flags;
ifvc.c:                LOG(LOG_NOTICE, 0, "buildIfVc: Multicast Enabled on %s.", IfDp->Name);
ifvc.c:        if (! (IfDp->aliases = (struct filters *)malloc(sizeof(struct filters))))
ifvc.c:        *IfDp->aliases = (struct filters){ {subnet, mask}, {INADDR_ANY, 0}, ALLOW, (uint8_t)-1, NULL };
ifvc.c:        LOG( LOG_DEBUG, 0, "buildIfVc: Interface %s Addr: %s, Flags: 0x%04x, MTU: %d, Network: %s, Ptr: %p", IfDp->Name, inetFmt(IfDp->InAdr.s_addr, 1), IfDp->Flags, IfDp->mtu, inetFmts(IfDp->aliases->src.ip, IfDp->aliases->src.mask, 2), IfDp->aliases);
ifvc.c:    for (IfDp = IfDescL; IfDp && strcmp(IfName, IfDp->Name) != 0; IfDp = IfDp->next);
ifvc.c:    for (IfDp = IfDescL; IfDp && IfDp->index != ix; IfDp = IfDp->next);
ifvc.c:    for (IfDp = IfDescL; IfDp; IfDp = IfDp->next, i++) {
ifvc.c:            total = (struct totals){ total.bytes + IfDp->bytes, total.rate + IfDp->rate, total.ratelimit + IfDp->conf->ratelimit };
ifvc.c:            sprintf(buf, msg, i, IfDp->Name, IfDp->index, IfDp->querier.ver, inetFmt(IfDp->InAdr.s_addr, 1), IS_DISABLED(IfDp->state) ? "Disabled" : IS_UPDOWNSTREAM(IfDp->state) ? "UpDownstream" : IS_DOWNSTREAM(IfDp->state) ? "Downstream" : "Upstream", inetFmt(IfDp->querier.ip, 2), IfDp->bytes, IfDp->rate, IfDp->conf->ratelimit);
ifvc.c:            sprintf(buf, msg, i, IfDp->Name, IfDp->index, IfDp->querier.ver, inetFmt(IfDp->InAdr.s_addr, 1), IS_DISABLED(IfDp->state) ? "Disabled" : IS_UPDOWNSTREAM(IfDp->state) ? "UpDownstream" : IS_DOWNSTREAM(IfDp->state) ? "Downstream" : "Upstream", inetFmt(IfDp->querier.ip, 2), IfDp->bytes, IfDp->rate, IfDp->conf->ratelimit);
ifvc.c:    for (IfDp = IfDescL; IfDp; IfDp = IfDp->next, i++) {
ifvc.c:        for (filter = IfDp->conf->filters; filter; filter = filter->next, i++) {
ifvc.c:                sprintf(buf, msg, i == 1 ? IfDp->Name : "", i, inetFmts(filter->src.ip, filter->src.mask, 1), inetFmts(filter->dst.ip, filter->dst.mask, 2), filter->dir == 1 ? "up" : filter->dir == 2 ? "down" : "both", filter->action == ALLOW ? "Allow" : filter->action == BLOCK ? "Block" : "Ratelimit", s);
ifvc.c:                sprintf(buf, msg, IfDp->Name, i, inetFmts(filter->src.ip, filter->src.mask, 1), inetFmts(filter->dst.ip, filter->dst.mask, 2), filter->dir == 1 ? "up" : filter->dir == 2 ? "down" : "both", filter->action == ALLOW ? "Allow" : filter->action == BLOCK ? "Block" : "Ratelimit", s);
igmp.c:        LOG(LOG_WARNING, 0, "%s on %s is not a valid Multicast group. Ignoring", inetFmt(group, 1), IfDp->Name);
igmp.c:        LOG(LOG_DEBUG, 0, "checkIgmp: Local multicast on %s and proxylocalmc is not set. Ignoring.", IfDp->Name);
igmp.c:    else if ((IfDp->state & ifstate) == 0) {
igmp.c:        strcat(strcpy(msg, ""), IS_UPSTREAM(IfDp->state) ? "upstream interface " : IS_DOWNSTREAM(IfDp->state) ? "downstream interface " : "disabled interface ");
igmp.c:        LOG(LOG_INFO, 0, "checkIgmp: Message for %s was received on %s. Ignoring.", inetFmt(group, 1), strcat(msg, IfDp->Name));
igmp.c:            LOG(LOG_NOTICE, 0, "Received WRONGVIF Upcall for Src %s Dst %s on %s.", inetFmt(igmpMsg->im_src.s_addr, 1), inetFmt(igmpMsg->im_dst.s_addr, 2), IfDp->Name);
igmp.c:    else if (src == IfDp->InAdr.s_addr || (IfDp->querier.ip == IfDp->conf->qry.ip && src == IfDp->querier.ip))
igmp.c:        LOG(LOG_NOTICE, 0, "acceptIgmp: The request from: %s for: %s on: %s is from myself. Ignoring.", inetFmt(src, 1), inetFmt(dst, 2), IfDp->Name);
igmp.c:        LOG(LOG_NOTICE, 0, "acceptIgmp: The request from: %s for: %s on: %s is invalid. Ignoring.", inetFmt(src, 1), inetFmt(dst, 2), IfDp->Name);
igmp.c:        LOG(LOG_WARNING, 0, "acceptIgmp: Received packet from: %s for: %s on: %s checksum incorrect.", inetFmt(src, 1), inetFmt(dst, 2), IfDp->Name);
igmp.c:            if (dst == allhosts_group && CONFIG->querierElection && IfDp->conf->qry.election && !IS_DISABLED(IfDp->state))
igmp.c:    if (grec && (IfDp->querier.ver == 1 || (IfDp->querier.ver == 2 && grec->grec_nsrcs > 0))) {
igmp.c:        LOG(LOG_NOTICE, 0, "Request to send group specific query on %s while in v%d mode, not sending.", IfDp->Name, IfDp->querier.ver);
igmp.c:        LOG(LOG_WARNING, 0, "IGMP request to %s on %s not valid, not sending.", inetFmt(grec->grec_mca.s_addr, 1), IfDp->Name);
igmp.c:    ip->ip_src.s_addr  = IfDp->querier.ip;
igmp.c:    igmpv3->igmp_code         = IfDp->querier.ver == 1 ? 0 : grec ? IfDp->conf->qry.lmInterval : IfDp->querier.mrc;
igmp.c:    igmpv3->igmp_misc         = (grec && grec->grec_type | 0x1 ? 0x8 : 0) + IfDp->querier.qrv;    // set router suppress flag.
igmp.c:    igmpv3->igmp_qqi          = grec ? IfDp->conf->qry.lmInterval : IfDp->querier.qqi;
igmp.c:    len = IP_HEADER_RAOPT_LEN + (IfDp->querier.ver != 3 ? 8 : IGMPV3_MINLEN + (igmpv3->igmp_numsrc * sizeof(struct in_addr)));
igmp.c:        LOG(LOG_WARNING, errno, "sendIGMP: from %s to %s (%d) on %s", inetFmt(IfDp->querier.ip, 2), inetFmt(ip->ip_dst.s_addr, 1), len, IfDp->Name);
igmp.c:    LOG(LOG_DEBUG, 0, "sendIGMP: %s from %-15s to %s (%d:%d:%d)", igmpPacketKind(igmpv3->igmp_type, igmpv3->igmp_code), IfDp->querier.ip == INADDR_ANY ? "INADDR_ANY" : inetFmt(IfDp->querier.ip, 1), inetFmt(ip->ip_dst.s_addr, 2), igmpv3->igmp_code, igmpv3->igmp_misc, igmpv3->igmp_qqi);
igmp.c:        if ((! IfDp->oldconf || IS_DOWNSTREAM(IF_OLDSTATE(IfDp))) && IS_DISABLED(IF_NEWSTATE(IfDp))) {
igmp.c:        timer_clearTimer(IfDp->querier.Timer);
igmp.c:        timer_clearTimer(IfDp->querier.ageTimer);
igmp.c:        memset(&IfDp->querier, 0, sizeof(struct querier));
igmp.c:        IfDp->querier.ip = (uint32_t)-1;
igmp.c:            IfDp->conf->qry.ver = 3;
igmp.c:        uint16_t interval = IfDp->conf->qry.ver == 3 ? getIgmpExp(IfDp->conf->qry.interval, 0) : IfDp->conf->qry.ver == 2 ? IfDp->conf->qry.interval : 10;
igmp.c:        IfDp->conf->qry.startupQueryInterval = interval > 4 ? (IfDp->conf->qry.ver == 3 ? getIgmpExp(interval / 4, 1) : interval / 4) : 1;
igmp.c:        IfDp->conf->qry.startupQueryCount = IfDp->conf->qry.robustness;
igmp.c:              timeout = IfDp->querier.ver == 3 ? (((getIgmpExp(igmpv3->igmp_qqi, 1) * (igmpv3->igmp_misc & 0x07)) * 10) + getIgmpExp(igmpv3->igmp_code, 1) / 2) : ver == 2 ? (((IfDp->conf->qry.interval * IfDp->conf->qry.robustness) * 10) + igmpv3->igmp_code / 2) : ((100 * IfDp->conf->qry.robustness) + 5);
igmp.c:    if (ver < IfDp->querier.ver || (ver == IfDp->querier.ver && (htonl(src) <= htonl(IfDp->querier.ip)))) {
igmp.c:        IfDp->querier = (struct querier){ src, ver, ver == 3 ? (igmpv3->igmp_qqi > 0 ? igmpv3->igmp_qqi : DEFAULT_INTERVAL_QUERY) : IfDp->conf->qry.interval, ver == 3 ? ((igmpv3->igmp_misc & 0x7) > 0 ? igmpv3->igmp_misc & 0x7 : DEFAULT_ROBUSTNESS) : IfDp->conf->qry.robustness, ver != 1 ? igmpv3->igmp_code : 10, IfDp->querier.Timer, IfDp->querier.ageTimer };
igmp.c:        if (IS_DOWNSTREAM(IfDp->state)) {
igmp.c:            timer_clearTimer(IfDp->querier.ageTimer);
igmp.c:            IfDp->querier.ageTimer = timer_setTimer(TDELAY(ver == 3 ? getIgmpExp(igmpv3->igmp_code, 1) : ver ==  2 ? igmpv3->igmp_code : 10), strcat(strcpy(msg, "Age Active Routes: "), IfDp->Name), (timer_f)ageRoutes, IfDp);
igmp.c:        timer_clearTimer(IfDp->querier.Timer);
igmp.c:        sprintf(msg, "%sv%1d Querier Timer: ", IS_DOWNSTREAM(IfDp->state) ? "Other " : "", ver);
igmp.c:        IfDp->querier.Timer = timer_setTimer(TDELAY(timeout), strcat(msg, IfDp->Name), (timer_f)expireQuerierTimer, IfDp);
igmp.c:        LOG(LOG_INFO, 0, "Detected %sv%d IGMP querier %s (%d:%d:%d) on %s. Setting Timer for %ds.", IS_DOWNSTREAM(IfDp->state) ? "other " : "", ver, inetFmt(src, 1), IfDp->querier.qqi, IfDp->querier.mrc, IfDp->querier.qrv, IfDp->Name, timeout / 10);
igmp.c:        LOG(LOG_DEBUG, 0, "Received IGMP v%d general membership query from %s on %s, but it does not have priority over %s. Ignoring", ver, inetFmt(src, 1), IfDp->Name, IfDp->querier.ip == IfDp->conf->qry.ip ? "us" : inetFmt(IfDp->querier.ip, 2));
igmp.c:    if (!IS_DOWNSTREAM(IfDp->state)) {
igmp.c:        LOG(LOG_INFO, 0, "Requested to send a query on %s, but it is %s. Query not sent.", IfDp->Name, IS_UPSTREAM(IfDp->state) ? "upstream" : "disabled");
igmp.c:        IfDp->querier = (struct querier){ IfDp->conf->qry.ip, IfDp->conf->qry.ver, IfDp->conf->qry.interval, IfDp->conf->qry.robustness, IfDp->conf->qry.responseInterval, 0, 0 };
igmp.c:        IfDp->conf->qry.startupQueryCount = IfDp->conf->qry.startupQueryCount > 0 ? IfDp->conf->qry.startupQueryCount - 1 : 0;
igmp.c:        int timeout = IfDp->querier.ver == 3 ? (getIgmpExp(IfDp->conf->qry.startupQueryCount > 0 ? IfDp->conf->qry.startupQueryInterval : IfDp->querier.qqi, 0)) : (IfDp->conf->qry.startupQueryCount > 0 ? IfDp->conf->qry.startupQueryInterval : IfDp->querier.qqi);
igmp.c:        IfDp->querier.Timer = timer_setTimer(TDELAY(timeout * 10), strcat(strcpy(msg, "General Query: "), IfDp->Name), (timer_f)sendGeneralMemberQuery, IfDp);
igmp.c:        timeout = IfDp->querier.ver != 3 ? IfDp->querier.mrc : getIgmpExp(IfDp->querier.mrc, 0);
igmp.c:        IfDp->querier.ageTimer = timer_setTimer(TDELAY(timeout), strcat(strcpy(msg, "Age Active Routes: "), IfDp->Name), (timer_f)ageRoutes, IfDp);
igmp.c:        LOG(LOG_DEBUG, 0, "Sent membership query from %s to %s on %s. Delay: %d", inetFmt(IfDp->querier.ip, 1), inetFmt(allhosts_group, 2), IfDp->Name, IfDp->conf->qry.responseInterval);
igmp.c:    LOG(LOG_NOTICE, 0, "Querier %s on %s expired.", inetFmt(IfDp->querier.ip, 1), IfDp->Name);
igmp.c:    if (IS_DOWNSTREAM(IfDp->state)) {
igmp.c:        timer_clearTimer(IfDp->querier.ageTimer);
igmp.c:        IfDp->querier.ip = (uint32_t)-1;
igmp.c:        IfDp->querier.Timer = 0;
igmpproxy.h:#define IQUERY (IfDp->querier.ip == IfDp->conf->qry.ip)
kern.c:    struct in_addr adr = { IfDp ? IfDp->InAdr.s_addr : INADDR_ANY };
kern.c:    GrpReq.gr_interface = IfDp ? if_nametoindex(IfDp->Name) : 0;
kern.c:    GrpReq.imr_interface.s_addr = IfDp ? IfDp->InAdr.s_addr : (struct in_addr){ 0 };
kern.c:        LOG(LOG_WARNING, errno, "MCAST_%s_GROUP %s on %s failed", Cmd == 'j' ? "JOIN" : "LEAVE", inetFmt(mcastaddr, 1), IfDp->Name)
kern.c:    if (IfDp->index == (uint8_t)-1) return;
kern.c:    vifCtl.vifc_vifi = IfDp->index;
kern.c:    LOG(LOG_NOTICE, 0, "removing VIF, Ix %d Fl 0x%x IP 0x%08x %s, Threshold: %d, Ratelimit: %d", IfDp->index, IfDp->Flags, IfDp->InAdr.s_addr, IfDp->Name, IfDp->conf->threshold, IfDp->conf->ratelimit);
kern.c:        LOG(LOG_WARNING, errno, "delVIF: Error removing VIF %d:%s", IfDp->index, IfDp->Name);
kern.c:    IfDp->index = (uint8_t)-1;
kern.c:        IfDp->index = Ix;
kern.c:    vifCtl = (struct vifctl){ Ix, 0, IfDp->conf->threshold, 0, {{IfDp->InAdr.s_addr}}, {INADDR_ANY} };
kern.c:    vifCtl = (struct vifctl){ Ix, 0, IfDp->conf->threshold, 0, {IfDp->InAdr.s_addr}, {INADDR_ANY} };
kern.c:    IfDp->bytes = IfDp->rate = 0;
kern.c:    LOG(LOG_NOTICE, 0, "adding VIF %s, Ix %d, Fl 0x%x, IP %s, Threshold: %d, Ratelimit: %d", IfDp->Name, vifCtl.vifc_vifi, vifCtl.vifc_flags, inetFmt(vifCtl.vifc_lcl_addr.s_addr, 1), vifCtl.vifc_threshold, IfDp->conf->ratelimit);
kern.c:    for (struct filters *filter = IfDp->aliases; filter; filter = filter->next)
kern.c:        LOG(LOG_DEBUG, 0, "        Network for [%s] : %s", IfDp->Name, inetFmts(filter->src.ip, filter->src.mask, 1));
kern.c:        LOG(LOG_WARNING, errno, "addVIF: Error adding VIF %d:%s", IfDp->index, IfDp->Name);
kern.c:        IfDp->index = (uint8_t)-1;
rttable.c:        if (IS_UPSTREAM(IfDp->state) && (croute->group & group.mask) == group.ip) {
rttable.c:                bw = oAddr->vif == (IfDp->index) ? bw + oAddr->rate : bw;
rttable.c:        } else if (IS_DOWNSTREAM(IfDp->state) && (croute->group & group.mask) == group.ip && BIT_TST(croute->vifBits, IfDp->index)) {
rttable.c:                if (IfDp->index == oAddr->vif || BIT_TST(croute->vifBits, IfDp->index)) {
rttable.c:                    IfDp->bytes += bwUpc->bu_measured.b_bytes;
rttable.c:                    LOG(LOG_DEBUG, 0, "BW_UPCALL: Added %lld bytes to interface %s (%lld B/s), total %lld.", bwUpc->bu_measured.b_bytes, IfDp->Name, IfDp->rate, IfDp->bytes);
rttable.c:    for (GETIFL(IfDp)) IfDp->rate = 0;
rttable.c:                if (IfDp->index == oAddr->vif || BIT_TST(croute->vifBits, IfDp->index)) {
rttable.c:                    IfDp->rate += oAddr->rate;
rttable.c:                    LOG(LOG_DEBUG, 0, "BW_CONTROL: Added %lld B/s to interface %s (%lld B/s), total %lld.", oAddr->rate, IfDp->Name, IfDp->rate, IfDp->bytes);
rttable.c:        if (IfDp->index != (uint8_t)-1) {
rttable.c:            struct sioc_vif_req siocVReq = { IfDp->index, 0, 0, 0, 0 };
rttable.c:            uint64_t bytes = (IS_UPSTREAM(IfDp->state) ? siocVReq.ibytes : siocVReq.obytes) - IfDp->bytes;
rttable.c:            IfDp->bytes += bytes;
rttable.c:            IfDp->rate = bytes / CONFIG->bwControlInterval;
rttable.c:            LOG(LOG_DEBUG, 0, "BW_CONTROL: Added %lld bytes to interface %s (%lld B/s), total %lld.", bytes, IfDp->Name, IfDp->rate, IfDp->bytes);
rttable.c:    for (filter = old ? IfDp->oldconf->filters : IfDp->conf->filters; filter; filter = filter->next) {
rttable.c:                   LOG(LOG_NOTICE, 0, "BW_CONTROL: Group %s (%lld B/s) ratelimited on %s by filter %s (%lld B/s).", inetFmt(group, 1), bw, IfDp->Name, inetFmts(filter->dst.ip, filter->dst.mask, 2), filter->action);
rttable.c:            LOG(LOG_DEBUG, 0, "Not joining group %s on interface that received request (%s)", inetFmt(croute->group, 1), IfDp->Name);
rttable.c:                BIT_SET(croute->upstrState, IfDp->index);
rttable.c:                LOG(LOG_INFO, 0, "clearRoutes: Joined %s on new upstream interface %s.", inetFmt(croute->group, 1), IfDp->Name);
rttable.c:                        LOG(LOG_WARNING, 0, "clearRoutes: Removing source %s on %s from route %s, no longer allowed.",inetFmt (oAddr->src, 1), IfDp->Name, inetFmt(croute->group, 2));
rttable.c:                        LOG(LOG_WARNING, 0, "clearRoutes: Leaving group %s on %s, no longer allowed.", inetFmt(croute->group, 1), IfDp->Name);
rttable.c:                            BIT_CLR(croute->upstrState, IfDp->index);
rttable.c:                            LOG(LOG_INFO, 0, "clearRoutes: Joining group %s on %s, it is now allowed.", inetFmt(croute->group, 1), IfDp->Name);
rttable.c:                            BIT_SET(croute->upstrState, IfDp->index);
rttable.c:            } else if (!IS_UPSTREAM(newstate) && BIT_TST(croute->upstrState, IfDp->index)) {
rttable.c:                LOG(LOG_WARNING, 0, "clearRoutes: Leaving group %s on %s, no longer upstream.", inetFmt(croute->group, 1), IfDp->Name);
rttable.c:                    BIT_CLR(croute->upstrState, IfDp->index);
rttable.c:                    if (BIT_TST(oAddr->vif, IfDp->index)) {
rttable.c:        if (!NOSIG && keep && IS_DOWNSTREAM(oldstate) && BIT_TST(croute->vifBits, IfDp->index)) {
rttable.c:                LOG(LOG_DEBUG, 0, "clearRoutes: Group %s now allowed on Vif %d - %s", inetFmt(croute->group, 1), IfDp->index, IfDp->Name);
rttable.c:                    LOG(LOG_INFO, 0, "clearRoutes: Group %s no longer allowed on Vif %d - %s, removing from route.", inetFmt(croute->group, 1), IfDp->index, IfDp->Name);
rttable.c:                    LOG(LOG_INFO, 0, "clearRoutes: Vif %d - %s removed, removing from route %s.", IfDp->index, IfDp->Name, inetFmt(croute->group, 1));
rttable.c:                    BIT_CLR(croute->vifBits, IfDp->index);
rttable.c:    if (IQUERY && !BIT_TST(dsrc->lmBits, IfDp->index)) {
rttable.c:        BIT_SET(dsrc->vifBits, IfDp->index);
rttable.c:        BIT_SET(dsrc->lmBits, IfDp->index);
rttable.c:        dsrc->age[IfDp->index] = IfDp->conf->qry.lmCount;
rttable.c:        dsrc->qCnt[IfDp->index]++;
rttable.c:        LOG(LOG_INFO, 0, "Detected v1 host on %s. Setting compatibility mode for %s.", IfDp->Name, inetFmt(croute->group, 1));
rttable.c:        BIT_SET(croute->v1Bits, IfDp->index);
rttable.c:        croute->v1Age[IfDp->index] = IfDp->querier.qrv;
rttable.c:        LOG(LOG_INFO, 0, "Detected v2 host on %s. Setting compatibility mode for %s.", IfDp->Name, inetFmt(croute->group, 2));
rttable.c:        BIT_SET(croute->v2Bits, IfDp->index);
rttable.c:        croute->v2Age[IfDp->index] = IfDp->querier.qrv;
rttable.c:        if ((BIT_TST(croute->v1Bits, IfDp->index) || BIT_TST(croute->v2Bits, IfDp->index || IfDp->querier.ver < 3)) && nsrcs > 0) {
rttable.c:            LOG(LOG_INFO, 0, "updateRoute: Ignoring %d sources for %s on %s, v1 or v2 host/querier present.", nsrcs, inetFmt(croute->group, 1), IfDp->Name);
rttable.c:            LOG(LOG_NOTICE, 0, "Group %s may not be requested on %s.", inetFmt(croute->group, 1), IfDp->Name);
rttable.c:        LOG(LOG_DEBUG, 0, "updateRoute: Processing %s with %d sources for %s (%s) on %s.", type == IGMPV3_MODE_IS_EXCLUDE ? "IS_EX" : "TO_EX", nsrcs, inetFmt(croute->group, 1), BIT_TST(croute->mode, IfDp->index) ? "EX" : "IN", IfDp->Name);
rttable.c:        croute->age[IfDp->index] = IfDp->querier.qrv;  // Group timer = GMI
rttable.c:        BIT_SET(croute->vifBits, IfDp->index);
rttable.c:        BIT_CLR(croute->lmBits, IfDp->index);
rttable.c:            for (dsrc = croute->dSources; dsrc; BIT_CLR(dsrc->vifBits, IfDp->index), clearDownstreamHost(dsrc->downstreamHostsHashTable, src), dsrc = dsrc->next);
rttable.c:            LOG(LOG_INFO, 0, "updateRoute: Removing all sources for %s on %s (Ex{}).", inetFmt(croute->group, 1), IfDp->Name);
rttable.c:            if (!BIT_TST(dsrc->vifBits, IfDp->index))
rttable.c:                BIT_CLR(dsrc->vifBits, IfDp->index);
rttable.c:            else if (type == IGMPV3_CHANGE_TO_EXCLUDE && (!BIT_TST(croute->mode, IfDp->index) || dsrc->age[IfDp->index] > 0))
rttable.c:            if (! BIT_TST(dsrc->vifBits, IfDp->index)) {
rttable.c:                BIT_SET(dsrc->vifBits, IfDp->index);
rttable.c:                if (type == IGMPV3_CHANGE_TO_EXCLUDE && BIT_TST(croute->mode, IfDp->index))
rttable.c:                else if (BIT_TST(croute->mode, IfDp->index))
rttable.c:                    dsrc->age[IfDp->index] = IfDp->querier.qrv;
rttable.c:                    dsrc->age[IfDp->index] = 0;
rttable.c:        BIT_SET(croute->mode, IfDp->index);
rttable.c:        if (BIT_TST(croute->v1Bits, IfDp->index) || IfDp->querier.ver == 1) {
rttable.c:            LOG(LOG_INFO, 0, "updateRoute: Ignoring TO_IN for %s on %s, v1 host/querier present.", inetFmt(croute->group, 1), IfDp->Name);
rttable.c:            if (IQUERY && !BIT_TST(croute->lmBits, IfDp->index))
rttable.c:            BIT_SET(croute->vifBits, IfDp->index);
rttable.c:        LOG(LOG_DEBUG, 0, "updateRoute: Processing %s with %d sources for %s (%s) on %s.", type == IGMPV3_MODE_IS_INCLUDE ? "IS_IN" : type == IGMPV3_ALLOW_NEW_SOURCES ? "ALLOW" : "TO_IN", nsrcs, inetFmt(croute->group, 1), BIT_TST(croute->mode, IfDp->index) ? "EX" : "IN", IfDp->Name);
rttable.c:                LOG(LOG_NOTICE, 0, "Group %s from %s may not be requested on %s.", inetFmt(croute->group, 1), inetFmt(grec->grec_src[i].s_addr, 2), IfDp->Name);
rttable.c:            if (!BIT_TST(dsrc->vifBits, IfDp->index) || dsrc->age[IfDp->index] > 0) {
rttable.c:                BIT_SET(dsrc->vifBits, IfDp->index);
rttable.c:                BIT_CLR(dsrc->lmBits, IfDp->index);
rttable.c:                dsrc->age[IfDp->index] = IfDp->querier.qrv;
rttable.c:            } else if (dsrc->age[IfDp->index] == 0) {
rttable.c:                BIT_CLR(dsrc->vifBits, IfDp->index);
rttable.c:                if (!BIT_TST(dsrc->vifBits, IfDp->index) || dsrc->age[IfDp->index] == 0)
rttable.c:        if (BIT_TST(croute->v1Bits, IfDp->index) || BIT_TST(croute->v2Bits, IfDp->index) || IfDp->querier.ver < 3) {
rttable.c:            LOG(LOG_INFO, 0, "updateRoute: Ignoring BLOCK for %s on %s, v1 or v2 host/querier present.", inetFmt(croute->group, 1), IfDp->Name);
rttable.c:            LOG(LOG_NOTICE, 0, "Group %s may not be requested on %s.", inetFmt(croute->group, 1), IfDp->Name);
rttable.c:        LOG(LOG_DEBUG, 0, "updateRoute: Processing BLOCK with %d sources for %s (%s) on %s.", nsrcs, inetFmt(croute->group, 1), BIT_TST(croute->mode, IfDp->index) ? "EX" : "IN", IfDp->Name);
rttable.c:            if (BIT_TST(croute->mode, IfDp->index)) {
rttable.c:                for (dsrc = croute->dSources; dsrc && (!BIT_TST(dsrc->vifBits, IfDp->index) || dsrc->ip != grec->grec_src[i].s_addr); dsrc = dsrc->next);
rttable.c:    } else if (!BIT_TST(croute->mode, IfDp->index)) {
rttable.c:        for (dsrc = croute->dSources; dsrc && !BIT_TST(dsrc->vifBits, IfDp->index); dsrc = dsrc->next);
rttable.c:            LOG(LOG_INFO, 0, "updateRoute: Removed group %s from %s (IN{}).", inetFmt(croute->group, 1), IfDp->Name);
rttable.c:            BIT_CLR(croute->vifBits, IfDp->index);
rttable.c:    LOG(LOG_DEBUG, 0, "Updated route entry for %s on VIF #%d", inetFmt(croute->group, 1), IfDp->index);
rttable.c:        LOG(LOG_INFO, 0, "startQuery: Querying group %s on %s.", inetFmt(croute->group, 1), IfDp->Name);
rttable.c:        BIT_SET(croute->lmBits, IfDp->index);
rttable.c:        BIT_SET(croute->gsqBits, IfDp->index);
rttable.c:        croute->age[IfDp->index] = IfDp->conf->qry.lmCount;
rttable.c:        croute->qCnt[IfDp->index]++;
rttable.c:        LOG(LOG_INFO, 0, "startQuery: Querying %d sources for %s on %s.", qlst[0], inetFmt(croute->group, 1), IfDp->Name);
rttable.c:        BIT_SET(croute->gssqBits, IfDp->index);
rttable.c:    strcpy((char *)&query->grec_src[nsrcs] + sizeof(void *), IfDp->Name);
rttable.c:    if (! IfDp || IS_DISABLED(IfDp->state)) {
rttable.c:        croute->qCnt[IfDp->index]--;
rttable.c:        if ((grec->grec_type == 0 || grec->grec_type == 1) && croute->qCnt[IfDp->index] > 1) {
rttable.c:            croute->qCnt[IfDp->index]--;
rttable.c:            if (!BIT_TST(croute->lmBits, IfDp->index)) {
rttable.c:                LOG(LOG_INFO, 0, "sendGSQ: %s no longer in last member state on %s.", inetFmt(croute->group, 1), IfDp->Name);
rttable.c:                BIT_CLR(croute->gsqBits, IfDp->index);
rttable.c:            } else if (--croute->age[IfDp->index] == 0)
rttable.c:                if (! dsrc || dsrc->qCnt[IfDp->index] > 1 || (--dsrc->age[IfDp->index] == 0 && !BIT_TST(croute->mode, IfDp->index))) {
rttable.c:                        LOG(LOG_NOTICE, 0, "Source %s was removed from group %s on %s, stop querying.", inetFmt(grec->grec_src[i].s_addr, 1), inetFmt(croute->group, 2), IfDp->Name);
rttable.c:                    else if (dsrc->qCnt[IfDp->index] > 1) {
rttable.c:                        dsrc->qCnt[IfDp->index]--;
rttable.c:                    if (BIT_TST(dsrc->lmBits, IfDp->index) && IQUERY) {
rttable.c:                        LOG(LOG_INFO, 0, "sendGSQ: Source %s for group %s no longer in last member state on %s.", inetFmt(dsrc->ip, 1), inetFmt(croute->group, 1), IfDp->Name);
rttable.c:    if (grec->grec_auxwords++ < IfDp->conf->qry.lmCount) {
rttable.c:        strcpy((char *)&grec->grec_src[grec->grec_nsrcs] + sizeof(void *), IfDp->Name);
rttable.c:        sprintf(msg, "GSQ (%s): %15s/%u", IfDp->Name, inetFmt(grec->grec_mca.s_addr, 1), grec->grec_nsrcs);
rttable.c:        timer_setTimer(TDELAY(IfDp->querier.ver == 3 ? getIgmpExp(IfDp->conf->qry.lmInterval, 0) : IfDp->conf->qry.lmInterval), msg, (timer_f)sendGroupSpecificQuery, grec);
rttable.c:        LOG(LOG_DEBUG, 0, "sendGSQ: Done querying %d sources for %s on %s.", nsrcs, inetFmt(grec->grec_mca.s_addr, 1), IfDp->Name);
rttable.c:            croute->qCnt[IfDp->index]--;
rttable.c:            BIT_CLR(croute->gsqBits, IfDp->index);
rttable.c:            if (BIT_TST(croute->lmBits, IfDp->index)) {
rttable.c:                BIT_CLR(croute->lmBits, IfDp->index);
rttable.c:            BIT_CLR(croute->gssqBits, IfDp->index);
rttable.c:                        dsrc->qCnt[IfDp->index]--;
rttable.c:                        if (BIT_TST(dsrc->lmBits, IfDp->index)) {
rttable.c:                            BIT_CLR(dsrc->lmBits, IfDp->index);
rttable.c:            LOG(LOG_DEBUG, 0, "sendGSQ: Removed group %s after aging.", inetFmt(croute->group, 2), IfDp->Name);
rttable.c:    LOG(LOG_INFO, 0, "TO_IN: Switching mode for %s to include on %s.", inetFmt(croute->group, 1), IfDp->Name);
rttable.c:    BIT_CLR(croute->mode, IfDp->index);
rttable.c:         if (BIT_TST(dsrc->vifBits, IfDp->index) && dsrc->age[IfDp->index] == 0) {
rttable.c:        LOG(LOG_INFO, 0, "Route activation for group: %s from src: %s on VIF[%d - %s]", inetFmt(group, 1), inetFmt(src, 2), IfDp->index, IfDp->Name);
rttable.c:            *nAddr = (struct originAddrs){ croute->origins, src, IfDp->index, 0, 0 };
rttable.c:    LOG(LOG_DEBUG, 0, "ageRoutes: Aging active routes on %s.", IfDp->Name);
rttable.c:        if (BIT_TST(croute->lmBits, IfDp->index)) {
rttable.c:        } else if (BIT_TST(croute->vifBits, IfDp->index)) {
rttable.c:            if (croute->v1Age[IfDp->index] == 0)
rttable.c:                BIT_CLR(croute->v1Bits, IfDp->index);
rttable.c:            else if (croute->v1Age[IfDp->index] > 0)
rttable.c:                croute->v1Age[IfDp->index]--;
rttable.c:            if (croute->v2Age[IfDp->index] == 0)
rttable.c:                BIT_CLR(croute->v2Bits, IfDp->index);
rttable.c:            else if (croute->v2Age[IfDp->index] > 0)
rttable.c:                croute->v2Age[IfDp->index]--;
rttable.c:                if (!BIT_TST(dsrc->vifBits, IfDp->index) || BIT_TST(dsrc->lmBits, IfDp->index))
rttable.c:                else if (dsrc->age[IfDp->index] == 0 && !BIT_TST(croute->mode, IfDp->index)) {
rttable.c:                    LOG(LOG_INFO, 0, "ageRoutes: Removed source %s from %s on %s after aging.", inetFmt(dsrc->ip, 1), inetFmt(croute->group, 2), IfDp->Name);
rttable.c:                } else if (dsrc->age[IfDp->index] > 0) {
rttable.c:                    dsrc->age[IfDp->index]--;
rttable.c:            if (BIT_TST(croute->mode, IfDp->index) && croute->age[IfDp->index] == 0)
rttable.c:            else if (croute->age[IfDp->index] > 0)
rttable.c:                croute->age[IfDp->index]--;
rttable.c:            if (!BIT_TST(croute->mode, IfDp->index)) {
rttable.c:                for (dsrc = croute->dSources; dsrc && !BIT_TST(dsrc->vifBits, IfDp->index); dsrc = dsrc->next);
rttable.c:                    LOG(LOG_INFO, 0, "ageRoutes: Removed group %s from %s after aging.", inetFmt(croute->group, 2), IfDp->Name);
rttable.c:                    BIT_CLR(croute->vifBits, IfDp->index);
rttable.c:            LOG(LOG_DEBUG, 0, "ageRoutes: Removed group %s after aging.", inetFmt(croute->prev->group, 2), IfDp->Name);
rttable.c:                if (IS_DOWNSTREAM(IfDp->state) && BIT_TST(croute->vifBits, IfDp->index)) {
rttable.c:                    LOG(LOG_DEBUG, 0, "Setting TTL for Vif %d to %d", IfDp->index, IfDp->conf->threshold);
rttable.c:                    ttlVc[IfDp->index] = IfDp->conf->threshold;
rttable.c:                LOG(LOG_DEBUG, 0, msg, rcount, oAddr ? inetFmt(oAddr->src, 1) : "-", inetFmt(croute->group, 2), oAddr ? IfDp->Name : "",
rttable.c:                sprintf(buf, strcat(msg, "\n"), rcount, oAddr ? inetFmt(oAddr->src, 1) : "-", inetFmt(croute->group, 2), oAddr ? IfDp->Name : "",
